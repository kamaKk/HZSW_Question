首先当我看到这道题目的时候，首先想到了在数据结构中学习到的双栈将四则运算的后缀表达转换为中则表达式的方法，因为同样拥有多括号进行优先级运算的问题。
于是我将这部分题目当作是仅仅进行字符串重复操作​（乘法）和字符串拼接操作​（加法）的表达式，那么进行存储的也就可以从运算符和运算数据转变为数字部分和字符串部分。后续的解题思路就是根据这个双栈进行实现的。
先说明最后的完整思路：
	1.设定双栈，一个数字栈Number_Stack， 一个字符栈 Str_Stack， 一个公共的栈顶指针 top = -1；初始化为指向空的指针
	2.由于数字的大小可能是大于9的多字符数字，所以定义一个num用来存储最后的数字；
字符串也是同理，但是需要使用数组current来进行保存，因为一个字节仅仅只能保存一个字符，字符串需要使用数组来进行保存。（current初始化为空数组）
同时设定一个current_len来确定当前字符串的长度
	3.接下来就是遍历字符串的部分；（变量c为当前字符）
		[1].当c为'0' ~ '9'之间的数据说明是数字部分。采用num = num * 10 + (c - '0');来进行计算
		[2].当c为字符串，current[current_len++] = c;保存当前数据的数值到临时变量组中，并添加结束符current[current_len] = '\0';
		[3]. (1).当c为'['说明数字部分结束，将num进行压栈到Number_Stack栈中。Number_Stack[++top] = num;并将num置0
			 (2).将临时缓冲字符的当前字符串的深拷贝副本一同压入字符栈中。第一次碰见'['和'['前无字符的时候压入的就是初始化的空字符。
			 (3).将current_len = 0;current[0] = '\0';将这两变量进行重置。因为碰见'['说明有新的内层数据，并且这部分数据我们已经进行压栈处理。所以可以进行重置处理
		[4]. (1).当c为']'说名字符串部分结束，此时current里面保存的是最近的一个括号中的字符，num为0。
			 (2).取出栈顶元素获得数字部分int k = Number_Stack[top]; 字符部分char* prev = Str_Stack[top]; 同时进行栈顶指针的移动top--;
			 (3).定义一个临时缓冲区数组repeated用来存储最内层的字符部分。
			 (4).进行数据的交叉运算，将current的值和栈中取出的数字部分进行乘法运算获取新的字符串，存储到repeated中
			 (5).从栈中取出的字符部分就是内层数据需要进行拼接的前头，所以进行两个数据的拼接成最后的字符串new_current -> prev + repeated
			 (6).更新字符串，current = new_current;
		[5].返回数据current
	4.对代码结构进行内存优化
后续考虑到题目样本的数据长度未知，于是对于数组current采用动态数组的方案。增加了当前字符串缓冲区的容量current_capacity。同时对临时数组采用计算字符串长度进行动态变化大小的动态数组方案。

在书写过程中遇到的问题: 1.对于字符串入栈时机的问题，我最初认为字符串应该在遇到]时入栈，但这会导致一个关键矛盾：​入栈后需要立即弹出才能处理内层表达式，形成无效操作。后续对题目示例的分析后我明白
		'['是嵌套开始的信号，当前字符串current存储的是该层括号前的字符串片段​，因此，​在[时压栈才是正确的时机​。
					2.既然当前字符串current存储的是该层括号前的字符串片段​，那么当碰见']'的时候，current恰好存储最内层括号的完整内容。此时弹栈得到数字k刚好就是current中字符需要进行重复的次数。
		弹栈得到字符串prev刚好就是目标字符串的前头拼接元素。
					